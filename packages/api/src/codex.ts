export const dataDictionary = [
  {
    name: 'customer_id',
    type: 'uuid',
    description: 'Unique shopper identifier from the source file.',
    example: '2f1a5f3c-2b8c-4b09-9d3b-7b4f77a4d40a',
    nullable: false,
    notes: 'Stored for joins only; never shown unmasked in the UI.',
  },
  {
    name: 'first_name',
    type: 'string',
    description: 'Shopper first name from the source file.',
    example: 'Jordan',
    nullable: false,
    notes: 'PII; stored only in raw_import.',
  },
  {
    name: 'last_name',
    type: 'string',
    description: 'Shopper last name from the source file.',
    example: 'Reed',
    nullable: false,
    notes: 'PII; stored only in raw_import.',
  },
  {
    name: 'personal_verified_emails',
    type: 'string',
    description: 'Personal verified email(s) provided by the source.',
    example: 'jordan.reed@gmail.com',
    nullable: true,
    notes: 'PII; masked before use in any UI sample.',
  },
  {
    name: 'business_verified_emails',
    type: 'string',
    description: 'Business verified email(s) provided by the source.',
    example: 'jreed@northbayauto.com',
    nullable: true,
    notes: 'PII; masked before use in any UI sample.',
  },
  {
    name: 'email_primary',
    type: 'string',
    description: 'Primary email address chosen by the source.',
    example: 'jordan.reed@gmail.com',
    nullable: true,
    notes: 'PII; masked before use in any UI sample.',
  },
  {
    name: 'mobile_phone',
    type: 'string',
    description: 'Primary mobile phone number.',
    example: '4155552199',
    nullable: true,
    notes: 'PII; masked before use in any UI sample.',
  },
  {
    name: 'personal_city',
    type: 'string',
    description: 'City of residence.',
    example: 'Austin',
    nullable: false,
    notes: 'Normalized to Title Case in dim_geo.',
  },
  {
    name: 'personal_state',
    type: 'string (2-char)',
    description: 'State of residence.',
    example: 'TX',
    nullable: false,
    notes: 'Uppercased in dim_geo.',
  },
  {
    name: 'personal_zip',
    type: 'string (ZIP5)',
    description: 'ZIP code of residence.',
    example: '78745',
    nullable: false,
    notes: 'Left-padded to 5 digits.',
  },
  {
    name: 'skiptrace_credit_rating',
    type: 'string enum',
    description: 'Skiptrace credit rating bucket.',
    example: 'B',
    nullable: false,
    notes: 'Mapped into intent score bonus.',
  },
  {
    name: 'skiptrace_match_score',
    type: 'int',
    description: 'Skiptrace match confidence.',
    example: '82',
    nullable: false,
    notes: 'Used in intent scoring.',
  },
  {
    name: 'skiptrace_ip',
    type: 'string',
    description: 'IP address from skiptrace.',
    example: '73.146.22.10',
    nullable: true,
    notes: 'Stored for internal enrichment only.',
  },
  {
    name: 'vehicle_make',
    type: 'string',
    description: 'Vehicle make of interest.',
    example: 'Toyota',
    nullable: false,
    notes: 'Normalized to Title Case.',
  },
  {
    name: 'vehicle_model',
    type: 'string',
    description: 'Vehicle model of interest.',
    example: 'RAV4',
    nullable: false,
    notes: 'Normalized to Title Case.',
  },
  {
    name: 'model_year',
    type: 'int',
    description: 'Model year of the vehicle.',
    example: '2024',
    nullable: false,
    notes: 'Used to build year bands in the UI.',
  },
  {
    name: 'assignment_method',
    type: 'string',
    description: 'Assignment method from the source file.',
    example: 'auto-assign',
    nullable: true,
    notes: 'Not used in scoring.',
  },
  {
    name: 'source_file',
    type: 'string',
    description: 'File identifier for the import batch.',
    example: 'rowzero_export_2026_02_08.csv',
    nullable: true,
    notes: 'Helpful for auditing demo loads.',
  },
  {
    name: 'created_at',
    type: 'timestamp',
    description: 'Time the record was created.',
    example: '2026-02-08 22:21:00',
    nullable: false,
    notes: 'Parsed from CSV on import.',
  },
  {
    name: 'intent_score',
    type: 'int',
    description: 'Deterministic demo intent score (0-100).',
    example: '78',
    nullable: false,
    notes: 'Derived from customer_id hash + vehicle + match_score + credit_rating.',
  },
  {
    name: 'intent_tier',
    type: 'string',
    description: 'Intent tier derived from intent_score.',
    example: 'Hot',
    nullable: false,
    notes: 'Warm (30-59), Hot (60-79), SuperHot (80-100).',
  },
  {
    name: 'demo_multiplier_bucket',
    type: 'int',
    description: 'Deterministic expansion bucket (1-5).',
    example: '4',
    nullable: false,
    notes: 'Used to scale counts without duplicating rows.',
  },
  {
    name: 'demo_weight',
    type: 'int',
    description: 'Weight applied to aggregates to expand volume.',
    example: '5',
    nullable: false,
    notes: 'Bucket mapping: 1→1, 2→2, 3→3, 4→5, 5→8.',
  },
];

export const metricDefinitions = [
  {
    name: 'identified_shoppers',
    definition: 'Weighted count of shoppers in scope (sum of demo_weight).',
  },
  {
    name: 'high_intent_shoppers',
    definition: 'Weighted count of shoppers with intent_score >= 60 (Hot + SuperHot).',
  },
  {
    name: 'avg_intent_score',
    definition: 'Weighted average of intent_score for shoppers in scope.',
  },
  {
    name: 'opportunity_index',
    definition:
      'Composite 0-100 index blending avg_intent_score and high_intent ratio (40%).',
  },
];

export const demoAssumptions = [
  'Counts are scaled with a deterministic weight per shopper (no duplicate rows).',
  'Weights are assigned via demo_multiplier_bucket derived from a customer_id hash.',
  'Intent scores are deterministic (hash + vehicle + match score + credit rating).',
  'Any sample records shown in the UI are masked and limited to 10 rows.',
];

export const scoringRules = [
  'Seed hash uses customer_id + vehicle attributes + match score + credit rating.',
  'Base intent = (seed % 70) + floor(match_score / 8) + credit bonus.',
  'Credit bonus: A=18, B=12, C=8, D=4, E=0.',
  'Intent score is clamped to 0-100.',
  'Tiers: Warm 30-59, Hot 60-79, SuperHot 80-100.',
];
